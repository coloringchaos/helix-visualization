<!DOCTYPE html>
<html lang="en">

	<head>
		<title>helix viz</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel=stylesheet href="css/style.css"/>
	</head>

	<body>

		<script src="http://threejs.org/build/three.min.js"></script>
		<script src="http://threejs.org/examples/js/loaders/OBJLoader.js"></script>

		<script src="libs/OrbitControls.js"></script>

		<!-- don't think these are doing anything -->
<!-- 		// <script src="http://threejs.org/examples/js/Detector.js"></script>
		// <script src="http://threejs.org/examples/js/libs/stats.min.js"></script> -->

		<script>

		// MAIN

			// standard global variables
			var container, scene, camera, renderer, controls, stats;

			//custom global variables
			var mouseX = 0, mouseY = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2 ;

			init();
			animate();



		// FUNCTIONS

			function init() {

				// SCENE
				scene = new THREE.Scene();

				// CAMERA
				// camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				// camera.position.z = 50;

				// use this camera setup instead - 
				var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
				var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
				camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
				scene.add(camera);
				camera.position.set(0, 20, 0);
				camera.position.z = 50;
				//camera.lookOut needs to be called in render function below

				// RENDERER
				renderer = new THREE.WebGLRenderer({
					antialias: true,
					alpha:true
				});
				renderer.setClearColor( 0xffffff ); 
				renderer.setSize( window.innerWidth, window.innerHeight );

				container = document.createElement( 'div' );
				document.body.appendChild( container );
				container.appendChild( renderer.domElement );

				// EVENTS

				// CONTROLS
				controls = new THREE.OrbitControls( camera, renderer.domElement );

				// LIGHT
				var ambient = new THREE.AmbientLight( 0x000000 );
				scene.add( ambient );
				var directionalLight = new THREE.DirectionalLight( 0xffeedd );
				directionalLight.position.set( 0, 0, 1 );
				scene.add( directionalLight );

				// TEXTURE
				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {
					console.log( item, loaded, total );
				};

				// MODEL
				var loader = new THREE.OBJLoader( manager );
				loader.load( 'helix.obj', function ( object ) {

                    object.rotation.x = 20* Math.PI / 180;
                    object.rotation.z = 20* Math.PI / 180; // NOTE TO SELF... Math.PI / 180 converts a degrees into radians.
                    object.scale.x = 50;
                    object.scale.y = 50;
                    object.scale.z = 50;
                    obj = object;
					scene.add( obj );

				} );

				//there might be a better way to deal with this...
				// document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				window.addEventListener( 'resize', onWindowResize, false );

			} //end init

			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			// function onDocumentMouseMove( event ) {
			// 	// mouseX = ( event.clientX - windowHalfX ) / 2;
			// 	// mouseY = ( event.clientY - windowHalfY ) / 2;
			// 	mouseX = ( event.clientX - windowHalfX );
			// 	mouseY = ( event.clientY - windowHalfY );
			// }

			function checkIntersection() {
				//find if mouse is over the model

			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
				//it's not recognizing .obj object...
                // obj.rotation.y += (0.005);
                // obj.rotation.x %=360;

                // obj.rotateOnAxis(1, 0); //axis in vector and angle in radians

				// camera.position.x += ( mouseX - camera.position.x ) * .05;
				// camera.position.y += ( mouseY - camera.position.y ) * .05;

				camera.lookAt( scene.position );

				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>